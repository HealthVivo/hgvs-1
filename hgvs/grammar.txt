# HGVS Grammar
# 2013-09-16 10:25 Reece Hart <reecehart@gmail.com>

# For the purposes of this grammar, an HGVS variant is limited to the subset
# of the Mutnomen document [3] that defines variant positions reasonably
# precisely.
#
# The basic structure of an HGVS variant is:
#    <ac>:<type>.<posedit>
# where <ac> is a sequence accession, <type> determines the sequence type
# and coordinate system ([cgmnpr]), and <posedit> is a string/list/object of
# positions and edit operations.
# 
# The easiest way to describe this grammar is by way of example. For the
# variant NM_01234.5:c.[12A>C;34-56_78+90G>T] parses as follows:
#
#     NM_01234.5 : c . [ 12 A>C ; 34 -56 _ 78 +90 del ]
#     -----------------------------------------------    hgvs_variant
#     ----------   -     ----------------------------    ac, type, posedits (a list)
#                        ------   -------------------    two posedit instances
#                        -- ---   --------------- ---    posedit = interval,edit
#                        -- - -   ------   ------ ---    int = <start,end>; edit = <ref,alt>
#                        --       -- ---   -- ---        pos = <base,offset>
# In this diagram, contiguous dashes indicate both a node in the grammar
# and a python class instance. Subsequent lines of the diagram indicate
# object instance nesting.
# 
# In addition to the above, this grammar also supports "HGVS-lite"
# notations for position used at InVitae, like 'NM_01234.5:c.56'.  The
# hgvs_lite rule consists of a ref sequence, type, and position, and is
# parsed into corresponding objects.
#
# References:
# 1. http://www.hgvs.org/mutnomen/
# 2. Describing structural changes by extending HGVS sequence variation nomenclature.
#    http://www.ncbi.nlm.nih.gov/pubmed/21309030
# 3. A formalized description of the standard human variant nomenclature...
#    http://www.ncbi.nlm.nih.gov/pubmed/21992071
#


############################################################################
## Top-level parser
# Each of these right-hand productions is expected to return a SequenceVariant
# instance

# GOAL: hgvs_variant = hgvs_strict | hgvs_invitae | hgvs_lax | hgvs_position | hgvs_posedit 
hgvs_variant = hgvs_strict

# valid HGVS subset
hgvs_strict = c_variant | r_variant | gmn_variant # | p_variant

# invitae /additions/ to hgvs_strict
# i.e., this will NOT parse valid HGVS
# hgvs_invitae_additions = (copyN, delN)

# any_variant: lax syntactic parser
any_variant = accn:ac ':' any_type:type '.' any_posedit:posedit -> SequenceVariant(ac,type,posedit)
any_type = letter
any_posedit = <anything+>

## HGVS Position -- e.g., NM_01234.5:c.22+6 (without an edit)
hgvs_position = accn:ac ':' any_type:type '.' c_interval:pos -> HGVSPosition(ac, type, pos)


c_variant = accn:ac ':' 'c':type '.' c_posedit:posedit -> SequenceVariant(ac,type,posedit)
c_posedit = c_interval:pos dna_edit:edit -> PosEdit(pos=pos,edit=edit)

r_variant = accn:ac ':' 'r':type '.' r_posedit:posedit -> SequenceVariant(ac,type,posedit)
r_posedit = r_interval:pos rna_edit:edit -> PosEdit(pos=pos,edit=edit)

gmn_variant = accn:ac ':' gmn_type:type '.' gmn_posedit:posedit -> SequenceVariant(ac,type,posedit)
gmn_type = :x ?(x in 'gmn') -> x
gmn_posedit = interval:pos dna_edit:edit -> PosEdit(pos=pos,edit=edit)

p_variant = accn:ac ':' 'p':type '.' p_posedit:posedit -> SequenceVariant(ac,type,posedit)
p_posedit = p_interval:pos p_edit:edit -> PosEdit(pos=pos,edit=edit)



############################################################################
## Edits

dna_edit = dna_subst | dna_delins | dna_ins | dna_del | dna_dup
dna_del = 'del' (<num>|<dna*>):ref -> RefAlt(ref=ref,alt=None)
dna_delins = 'del' (<num>|<dna*>):ref 'ins' <dna+>:alt  -> RefAlt(ref=ref,alt=alt)
dna_dup = 'dup' <dna*>:seq -> Dup(seq=seq)
dna_ins = 'ins' <dna+>:alt -> RefAlt(ref=None,alt=alt)
dna_subst = dna:ref '>' dna:alt -> RefAlt(ref=ref,alt=alt)

rna_edit = rna_subst | rna_delins | rna_ins | rna_del | rna_dup
rna_del = 'del' (<num>|<rna*>):ref -> RefAlt(ref=ref,alt=None)
rna_delins = 'del' (<num>|<rna*>):ref 'ins' <rna+>:alt  -> RefAlt(ref=ref,alt=alt)
rna_dup = 'dup' <rna*>:seq -> Dup(seq=seq)
rna_ins = 'ins' <rna+>:alt -> RefAlt(ref=None,alt=alt)
rna_subst = rna:ref '>' rna:alt -> RefAlt(ref=ref,alt=alt)

p_edit = p_subst | p_delins | p_ins | p_del | p_dup
p_del = 'del' (<num>|<aa3*>):ref -> RefAlt(ref=ref,alt=None)
p_delins = 'del' (<num>|<aa3*>):ref 'ins' <aa3+>:alt  -> RefAlt(ref=ref,alt=alt)
p_dup = 'dup' <aa3*>:seq -> Dup(seq=seq)
p_ins = 'ins' <aa3+>:alt -> RefAlt(ref=None,alt=alt)
p_subst = <aa3+ p_fs?>:alt -> RefAlt(ref=None,alt=alt)
p_fs = 'fs' ('Ter'|'*') num?

############################################################################
## Basic types

dna_seq = <dna+>
dna = :x ?(x in 'ACGTacgt') -> x

rna_seq = <rna+>
rna = :x ?(x in 'ACGUacgu') -> x

aa1_seq = <aa1+>
aa1 = :x ?(x in 'ACDEFGHIKLMNPQRSTVWY*') -> x

aa3_seq = <aa3+>
aa3 = <letter{3}>:x ?(x in ['Ala','Cys','Asp','Glu','Phe','Gly','His','Ile','Lys','Leu',
                          'Met','Asn','Pro','Gln','Arg','Ser','Thr','Val','Trp','Tyr',
                          'Ter']) -> x

interval = (pos:start '_' pos:end -> Interval(start,end)) | (pos:start -> Interval(start,start))
r_interval = (r_pos:start '_' r_pos:end -> Interval(start,end)) | (r_pos:start -> Interval(start,start))
c_interval = (c_pos:start '_' c_pos:end -> Interval(start,end)) | (c_pos:start -> Interval(start,start))
p_interval = (p_pos:start '_' p_pos:end -> Interval(start,end)) | (p_pos:start -> Interval(start,start))

pos = num:pos -> SimplePosition(pos)
r_pos = snum:b (snum | -> 0):o -> BaseOffsetPosition(b,o,datum=hgvs.location.SEQ_START)
c_pos = snum:b (snum | -> 0):o -> BaseOffsetPosition(b,o,datum=hgvs.location.CDS_START)
		| '*' num:b (snum | -> 0):o -> BaseOffsetPosition(b,o,datum=hgvs.location.CDS_END)
p_pos = aa3:aa num:pos -> hgvs.location.AAPosition(pos,aa)


# Accessions, possibly versioned. Should accept, e.g., NM_01234.5, LRG_01234_1p1
accn = <letter letterOrDigit+ ('_' letterOrDigit+)? ('.' digit+)?>

snum = <pm? num>:x -> int(x)
num = <digit+>:x -> int(x)
pm = :x ?(x in '-+') -> x

Not_Yet_Implemented = 'NOT YET IMPLEMENTED'
